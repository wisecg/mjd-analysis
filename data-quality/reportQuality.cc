// reportQuality.cc
//
// Clint Wiseman, USC

// Channel Selection Criteria (0: true/pass, 1: false/fail)
// Bit 0: Channel enabled in ORCA
// Bit 1: HV off
// Bit 2: HV different by more than 1% from voltage @ prev. calibration
// Bit 3: FWHM at 2.6 MeV (most recent calibration) different by more than 5% from prev. calibration.
// Bit 4: “Noise rate” greater than 100 Hz.
// Bit 5: Threshold greater than 100 keV
// Bit 6: Gain change from previous and next calibration greater than 1%
// Bit 7: t50 time
// Bit 8: Live detector (> 0 events)
// Bit 9: Unstable baseline (MJSCDoc)
// Bit 10: Pulser monitor channel

// bit 11: MATCHING HG AND LG EVENTS - check mL and mH.  Should always have an event in both.
//         look for mL != mH && mL > mH && trapSUM > thresholdE
//         (check julieta's email to get it right)
// david asks if a pulser recovery event could cause us to have a LG event without a HG
// ... compare baseline of LG channel with average LG channel?
// ... are we triggering on only down-going pulser recovery events?

// M1 Pulser Monitor Channels (as of Nov. 2015)
// Monitor 	Pulses these MB's		Monitors these detectors
// 644		M1-1 alpha, M1-1 delta	P1D1 P1D2 P1D3 P1D4 P2D2 P2D3 P2D4
// 612		M1-1 gamma, M1-1 beta	P3D1 P3D2 P3D3 P3D4
// 596		M1-2 beta, M1-2 gamma	P2D1 P4D3 P4D4 P4D5 P5D1 P5D2 P5D3 P5D4 P6D4
// 676		M1-2 alpha, M1-2 delta	P4D1 P4D2 P6D1 P6D2 P6D3 P7D1 P7D2 P7D3 P7D4

#include <iostream>
#include <fstream>
#include <string>
#include <vector>
#include <tuple> // for adding TH2D's

#include "TCanvas.h"
#include "TH1.h"
#include "TH2.h"
#include "TChain.h"
#include "TStyle.h"
#include "TError.h"	// for gErrorIgnoreLevel
#include "TGraph.h"
#include "TGraphErrors.h"
#include "TMultiGraph.h"
#include "TGaxis.h" // for right-side axis
#include "TROOT.h" // for gROOT
#include "TSystem.h" // for AccessPathName
#include "TBenchmark.h" // for timers
#include "TKey.h" // for histo merge

#include "GATDataSet.hh"
#include "MJAnalysisDoc.hh"
#include "KTree.h"
#include "MJAnalysisParameters.hh" // for EnergyCalibration
#include "MJProvenance.hh"	// for kParametersSource
#include "MJSlowControlsDoc.hh"
#include "MJTRun.hh" // for start & stop unix times

using namespace std;
using namespace MJDB;
using namespace katrin; // for katrin::KTree

vector<double> GetCalibrationConstants(MJAnalysisDoc &doc, int run, int chan);
void GetStartStopTimes(string input, vector<long> &times);
void GetSlowControlData(string input, int chans[62], vector<long> &times, TFile *rangeInfo = NULL);
void ChannelQuality(string input, int chans[62]);
void MergeOutputFiles(int argc, char** argv, int chans[62]);
void makePlots(int argc, char** argv, int chans[62]);
void makeTex(string input, int chans[62]);

static const char Usage[] =
"\nUsage: ./reportQuality [file] [options]\n\n"
"     -C : Channel quality report. Looks for [file] in ./runs. Extension .txt is assumed.\n"
"     -S : Download slow controls DB file for a given run list.\n"
"     -D [Info File] : Download same DB file, but use start/stop times \n          from the run list generated by the -L option\n"
"     -M [file1] [file2] ... : Merge output files.\n"
"     -L [file1] [file2] ... : Find start/stop times for a run range.\n"
"     -P [infoFile] ...      : Create summary plots using [file] and the channel map in [infoFile].\n"
"     -T   : Generate Latex using range info file [file] \n\n"
"     ReportQuality requires MkCookie.  Have you run it during this session?\n"
"\n";

int main(int argc, char** argv)
{
	// List of all 58 possible channels in M1/DS1 (from channel map),
	// including the 4 pulser monitor channels at the end
	int DS1_M1Channels[62] = {600, 601, 598, 599, 594, 595, 592, 593, 632, 633, 630, 631, 626, 627, 690, 691, 692, 693, 648, 649, 640, 641, 642, 643, 584, 585, 582, 583, 580, 581, 578, 579, 616, 617, 610, 611, 608, 609, 664, 665, 680, 681, 678, 679, 672, 673, 696, 697, 624, 625, 628, 629, 688, 689, 694, 695, 614, 615, 644, 612, 596, 676};

	// Get input options
	if (argc == 1) {  cout << Usage;  return 0;  }
	string input = argv[1];
	argc -= optind; // reduces the argument number by optind
	argv += optind; // changes the pointer to go optind items after the first one
	int c;
	bool report=0, getSCFile=0, merge=0, startStop=0, getSCFileUsingList=0,summary=0,latex=0;
	while ((c = getopt (argc, argv, "CSMLDPT")) != -1)
	switch (c)
	{
	case 'C':
		report = 1;		break;
	case 'S':
		getSCFile = 1;  break;
	case 'M':
		merge = 1;  	break;
	case 'L':
		startStop = 1;  break;
	case 'D':
		getSCFileUsingList = 1;  break;
	case 'P':
		summary = 1;    break;
	case 'T':
		latex = 1;      break;
	}

	// Run routines (see usage above)
	vector<long> times;
	if (getSCFile) GetSlowControlData(input, DS1_M1Channels, times);
	if (report) ChannelQuality(input, DS1_M1Channels);
	if (merge) MergeOutputFiles(argc, argv, DS1_M1Channels);

	if (summary) {
		gROOT->ForceStyle();
		gROOT->ProcessLine(".x /Users/wisecg/dev/MJDClintPlotStyle.C");
		makePlots(argc,argv,DS1_M1Channels);
	}

	if (latex) makeTex(input, DS1_M1Channels);

	// -L option
	// Create a run start/stop info file for database queries.
	// This requires PDSF.
	// USAGE: ./reportQuality [output name] -L [file1] [file2] ...
	if (startStop)
	{
		string outputName = input;
		outputName += ".root";
		cout << "Output file: " << outputName << endl;
		TFile *f = new TFile(outputName.c_str(),"RECREATE");
		TTree *t = new TTree("rangeInfo","start/stop info");
		string fileName;
		Long64_t rangeStart, rangeStop, firstRun, lastRun;
		t->Branch("fileName",&fileName);
		t->Branch("rangeStart",&rangeStart);
		t->Branch("firstRun",&firstRun);
		t->Branch("rangeStop",&rangeStop);
		t->Branch("lastRun",&lastRun);
		for (int i = 2; i < argc; i++) {
			vector<long> times;
			fileName = argv[i];
			cout << "File : " << fileName << endl;
			GetStartStopTimes(fileName, times);
			rangeStart = (Long64_t)times[0];
			firstRun = (Long64_t)times[1];
			rangeStop = (Long64_t)times[2];
			lastRun = (Long64_t)times[3];
			t->Fill();
		}
		GATDataSet* tmpDS = new GATDataSet((int)lastRun);
		MJTChannelMap *map = tmpDS->GetChannelMap();
		delete tmpDS;
		map->Write();
		t->Write();
		f->Close();
	}

	// -D option
	// Download slow control data without accessing run info from PDSF,
	// using a pre-downloaded datafile created by the startStop (-L) option.
	// USAGE: ./reportQuality [DS1_00] -D [InfoFile]
	if (getSCFileUsingList)
	{
		string InfoFile = argv[2];
		InfoFile += ".root";
		TFile *f = new TFile(InfoFile.c_str());
		TTree *t = (TTree*)f->Get("rangeInfo");
		printf("\nUsing start/stop data file %s ... Found %lli entries.\n",InfoFile.c_str(),t->GetEntries());
		vector<long> times;
		string *fileName = new string();
		Long64_t rangeStart, firstRun, rangeStop, lastRun;
		t->SetBranchAddress("fileName",&fileName);
		t->SetBranchAddress("rangeStart",&rangeStart);
		t->SetBranchAddress("firstRun",&firstRun);
		t->SetBranchAddress("rangeStop",&rangeStop);
		t->SetBranchAddress("lastRun",&lastRun);
		t->GetEntry(0);
		for (int i = 0; i < t->GetEntries(); i++){
			t->GetEntry(i);
			string file(fileName->c_str()); // convert to std::string
			if (file == input){
				printf("Match!  %s  %lli  %lli  %lli  %lli\n",file.c_str(),rangeStart,firstRun,rangeStop,lastRun);
				times.push_back(rangeStart);
				times.push_back(firstRun);
				times.push_back(rangeStop);
				times.push_back(lastRun);
				break;
			}
		}
		GetSlowControlData(input,DS1_M1Channels,times,f);
	}
}


////////////////////////////////////////////////////////////////////
// ================ Run List Start & Stop Times ================= //
////////////////////////////////////////////////////////////////////

void GetStartStopTimes(string input, vector<long> &times)
{
	// Loop over input run list and get run info
	string runPath = "./runs/"+input+".txt";
	cout << "Getting start & stop times for : " << runPath << endl;
	ifstream InputList(runPath);
	int run = 0;
	vector <double> runList;
	while (true) {
		InputList >> run;
		if (InputList.eof()) break;
		runList.push_back((double)run);
	}

	// Pull out start/stop times for this run range
	GATDataSet* tmp1 = new GATDataSet(runList.front());
	TChain *blt1 = tmp1->GetBuiltChain();
	MJTRun *tmpRunInfo = new MJTRun();
	blt1->SetBranchAddress("run",&tmpRunInfo);
	blt1->GetEntry(0);
	long rangeStart = (long)tmpRunInfo->GetStartTime();
	delete tmp1;
	GATDataSet* tmp2 = new GATDataSet(runList.back());
	TChain *blt2 = tmp2->GetBuiltChain();
	blt2->SetBranchAddress("run",&tmpRunInfo);
	blt2->GetEntry(0);
	long rangeStop = (long)tmpRunInfo->GetStopTime();
	if (rangeStart>1800000000 || rangeStart<1300000000 || rangeStop>1800000000 || rangeStop<1300000000)
	{
		printf("Warning, corrupted rangeStart (%li) or rangeStop (%li) times!\n",rangeStart,rangeStop);

		// in case of no end of run record
		if (rangeStop>1800000000 || rangeStop<1300000000) {
			rangeStop = (long)tmpRunInfo->GetStartTime() + (long)tmp2->GetRunTime()/1E9;
			cout << "New rangeStop time: " << rangeStop << endl;
		}
	}
	delete tmp2;
	delete tmpRunInfo;
	times.clear();
	times.push_back(rangeStart);
	times.push_back((long)runList.front());
	times.push_back(rangeStop);
	times.push_back((long)runList.back());
}

////////////////////////////////////////////////////////////////////
// ================= Download Slow Control Data ================= //
// Access slow control database (requires internet connection)    //
////////////////////////////////////////////////////////////////////

void GetSlowControlData(string input, int chans[62], vector<long> &times, TFile *rangeInfo)
{
	TBenchmark bench;

	// If you specify times and a range info file, the routine doesn't
	// need to be run on PDSF.
	long rangeStart=0, rangeStop=0, lastRun=0;
	if (times.size() == 0) GetStartStopTimes(input, times);
	rangeStart = times[0];
	rangeStop = times[2];
	lastRun = times[3];
	MJTChannelMap *map;
	if (rangeInfo != NULL){
		map = dynamic_cast<MJTChannelMap*>(rangeInfo->Get("ChannelMap"));
	}
	else {
		GATDataSet* tmpDS = new GATDataSet((int)lastRun);
		map = tmpDS->GetChannelMap();
		delete tmpDS;
	}

	// Download the baseline history and leakage current values
	string slowFile = "./output/" + input + "_SC.root";
	cout << "Creating slow controls file : " << slowFile << endl << endl;
	MJSlowControlsDoc tmp;
	string startStr = tmp.GetGMTString(rangeStart);
	string stopStr = tmp.GetGMTString(rangeStop);
	string zone = "GMT";
	printf("\nDownloading slow controls history ...\n   File: '%s'\n   Start %s  Stop %s (GMT)\n", slowFile.c_str(), startStr.c_str(), stopStr.c_str());
	for (int i = 0; i < 58; i++)
	{
		char treename[200];
		if (chans[i] % 2 == 0)
		{
			bench.Start("detHist");
			MJSlowControlsDoc slow;
			string detSerial = map->GetString(chans[i],"kDetectorName");
			string query = "Baseline Voltage,"+detSerial;
			string strName = map->GetString(chans[i],"kStringName");
			string detPos = to_string(map->GetInt(chans[i],"kDetectorPosition"));
			string detector = strName+"D"+detPos;
			printf("\n   %i : Downloading %s history : %s \n", i/2, detector.c_str(), query.c_str());
			slow.SetDatabase(kHDB_DetHist,kFeresaValues,query,startStr,stopStr,zone,kIncDocs);
			// cout << "URL: " << slow.GetURL() << endl;
			slow.GrabHistory(); // true to dump values
			sprintf(treename,"%s_Baseline",detector.c_str());
			if (i == 0) slow.RootifyDocument(slowFile,query,treename);
			else slow.RootifyDocument(slowFile,query,treename,2);
			sprintf(treename,"%s_Leakage",detector.c_str());
			slow.RootifyBranch(slowFile,treename,"",2);
			bench.Show("detHist");
			bench.Reset();
		}
	}
}


////////////////////////////////////////////////////////////////////
// =================== Channel Quality Report =================== //
////////////////////////////////////////////////////////////////////

void ChannelQuality(string input, int chans[62])
{
	TBenchmark bench;

	// Loop over input run list and get run info
	string runPath = "./runs/"+input+".txt";
	cout << "Opening " << runPath << endl;
	ifstream InputList(runPath);
	int filesToScan = 0, run = 0;
	vector <double> runList;
	while (true) {
		InputList >> run;
		if (InputList.eof()) break;
		filesToScan++;
		runList.push_back((double)run);
	}
	InputList.clear();                 // clear fail and eof bits
	InputList.seekg(0, std::ios::beg); // back to the start!
	printf("\nScanning %i files ... First run: %.0f  Last run: %.0f\n",filesToScan,runList.front(),runList.back());

	// Pull out start/stop times for this run range
	GATDataSet* tmp1 = new GATDataSet(runList.front());
	TChain *blt1 = tmp1->GetBuiltChain();
	MJTRun *tmpRunInfo = new MJTRun();
	blt1->SetBranchAddress("run",&tmpRunInfo);
	blt1->GetEntry(0);
	long rangeStart = (long)tmpRunInfo->GetStartTime();
	delete tmp1;
	GATDataSet* tmp2 = new GATDataSet(runList.back());
	TChain *blt2 = tmp2->GetBuiltChain();
	blt2->SetBranchAddress("run",&tmpRunInfo);
	blt2->GetEntry(0);
	long rangeStop = (long)tmpRunInfo->GetStopTime();
	if (rangeStart>1800000000 || rangeStart<1300000000 || rangeStop>1800000000 || rangeStop<1300000000)
	{
		printf("Warning, corrupted rangeStart (%li) or rangeStop (%li) times!\n",rangeStart,rangeStop);

		// in case of no end of run record
		if (rangeStop>1800000000 || rangeStop<1300000000) {
			rangeStop = (long)tmpRunInfo->GetStartTime() + (long)tmp2->GetRunTime()/1E9;
			cout << "New rangeStop time: " << rangeStop << endl;
		}
	}
	delete tmp2;
	delete tmpRunInfo;
	// long rangeLength = rangeStop - rangeStart;


	// Create histogram arrays
	TH1D *hTrapENF[62];
	TGraph *hRate[62];
	TH2D *hTrapVRun[62];
	TGraph *hConst[62];
	vector<double> baselineMeans[62];
	vector<double> baselineRMSs[62];
	vector<double> leakageMeans[62];
	vector<double> leakageRMSs[62];
	int runRange = 1 + runList.back() - runList.front();
	printf("th2d range: bins: %i  xmin: %.0f  xmax: %.0f\n",runRange,runList.front(),runList.back()+1);
	for (int i = 0; i < 62; i++)
	{
		// reserve vector memory
		baselineMeans[i].reserve(filesToScan);
		baselineRMSs[i].reserve(filesToScan);
		leakageMeans[i].reserve(filesToScan);
		leakageRMSs[i].reserve(filesToScan);

		// energy spectra
		if (chans[i] % 2 == 0) hTrapENF[i] = new TH1D("","",3000,0,3000);
		else hTrapENF[i] = new TH1D("","",13000,0,13000);

		// rates vs run
		hRate[i] = new TGraph(0);

		// energy vs run
		int runRange = 1 + runList.back() - runList.front();
		if (chans[i] % 2 == 0) hTrapVRun[i] = new TH2D("", "", runRange, runList.front(), runList.back()+1, 300, 0, 3000);
		else hTrapVRun[i] = new TH2D("", "", runRange, runList.front(), runList.back()+1, 1300,0,13000);

		// calibration constants
		hConst[i] = new TGraph(0);

		// baselines & leakage currents :
		// declared after scan is complete using the vectors defined above
	}

	// Open slow control history root file in read-only mode
	// (Placed after histo creation so they are not associated with the TFile in memory)
	string slowFile = "./output/" + input + "_SC.root";
	TFile *scFile=0;
	if (!gSystem->AccessPathName(slowFile.c_str()))
		scFile = new TFile(slowFile.c_str());
	else {
		cout << "Slow controls file doesn't exist!  Exiting ...\n"; return;
	}

	///////////////////////////////////////////////////////////////////
	// ==================== Loop over run list ===================== //
	///////////////////////////////////////////////////////////////////

	// The last map is saved afterwards for help with plot naming.
	MJTChannelMap *map = 0;
	while (true)
	{
		InputList >> run;
		if (InputList.eof()) break;

		// Grab the data and settings for this run.
		GATDataSet *ds = new GATDataSet(run);
		map = ds->GetChannelMap();
		MJTChannelSettings *set = ds->GetChannelSettings();
		TChain *gat = ds->GetGatifiedChain();
		TChain *blt = ds->GetBuiltChain();
		double runLength = ds->GetRunTime()/1E9;
		MJTRun *runInfo = new MJTRun();
		blt->SetBranchAddress("run",&runInfo);
		blt->GetEntry(0);
		long start = (long)runInfo->GetStartTime();
		long stop = (long)runInfo->GetStopTime();

		// Access analysis parameters database (requires internet connection)
		MJAnalysisDoc doc;
		doc.Find_Runs(to_string(run));

		printf("\n------ Scanning run %i (%.0f s) ------\n", run, runLength);
		bench.Start("runScanTime");

		// Save the enabled channels and all possible channels,
		// then make sure they are present in the array chans
		vector<uint32_t> enab = set->GetEnabledIDList();
		vector<uint32_t> list;
		int numDetectors = (int)map->NumberOfRows();
		for(int i = 0; i < numDetectors; i++)
		{
			list.push_back(map->GetRowIndex(i)["kIDHi"].AsLong());
			list.push_back(map->GetRowIndex(i)["kIDLo"].AsLong());
		}
		bool channelMatch = true;
		bool exception = false;	// make an exception for known problem ranges.
		for (int i = 0; i < (int)list.size(); i++) {
			bool found = false;
			for (int j = 0; j < 62; j++) if ((int)list[i] == chans[j]) { found = true; continue; }
			if (!found) { cout << "Warning! Unexpected channel: " << list[i] << endl; channelMatch = false; }
		}
		for (int i = 0; i < (int)enab.size(); i++) {
			bool found = false;
			for (int j = 0; j < 62; j++) if ((int)enab[i] == chans[j]) { found = true; continue; }
			if (!found) { cout << "Warning! Unexpected ENABLED channel: " << enab[i] << endl; channelMatch = false; }
		}
		// for these runs, card 10 had wrong channels enabled (674,675,677).  No harm done.
		if (run >= 12607 && run <= 12674) exception = true;
		if (!channelMatch && !exception) { cout << "Exiting ... \n\n";  return; }

		// Loop over active channels for this run
		char cutstr[200];
		for (int i = 0; i < (int)enab.size(); i++)
		{
			if (exception && (enab[i]==674 || enab[i]==675 || enab[i]==677)) continue;

			// get channel index and detector names
			int chanIndex = -1;
			for (int j = 0; j < 62; j++) if ((int)enab[i] == chans[j]) { chanIndex = j; continue; }
			string strName = map->GetString(chans[i],"kStringName");
			string detPos = to_string(map->GetInt(chans[i],"kDetectorPosition"));
			string detector = strName+"D"+detPos;

			// TH1D : 1d energy spectra
			// TGraph : rate vs run
			// TH2D : energy vs run
			// TGraph : calibration constants (skip pulser monitors)
			// TGraph : baseline & leakage plots

			// energy
			TH1D *h0 = 0;
			if (enab[i] % 2 == 0) h0 = new TH1D("h0","",3000,0,3000);
			else h0 = new TH1D("h0","",13000,0,13000);
			sprintf(cutstr,"channel==%i",enab[i]);
			gat->Project("h0", "trapENFCal", cutstr);
			hTrapENF[chanIndex]->Add(h0);


			// rate vs. run
			double rate = (double)h0->GetEntries()/runLength;
			hRate[chanIndex]->SetPoint(hRate[chanIndex]->GetN(), run, rate);
			delete h0;


			// energy vs run
			TH2D *h1 = 0;
			int runRange = 1 + runList.back() - runList.front();
			if (enab[i] % 2 == 0) h1 = new TH2D("h1","", runRange, runList.front(), runList.back()+1, 300, 0, 3000);
			else h1 = new TH2D("h1","", runRange, runList.front(), runList.back()+1, 1300, 0, 13000);
			gat->Project("h1", "trapENFCal:run", cutstr);
			hTrapVRun[chanIndex]->Add(h1);
			delete h1;


			// calibration constants (skip pulser monitor channels)
			if (enab[i]==644 || enab[i]==612 || enab[i]==596 || enab[i]==676) continue;
			vector<double> constants = GetCalibrationConstants(doc, run, enab[i]);
			if (constants.size()!=12) {
				printf("Incomplete record!  Size %i  Run %i  Channel %i  \n", (int)constants.size(), run, enab[i]);
				continue;
			}
			hConst[chanIndex]->SetPoint(hConst[chanIndex]->GetN(), run, constants[4]);


			// check HV setting matches the target (skip pulser monitors)
			int hvCr = map->GetInt(enab[i],"kHVCrate");
			int hvCa = map->GetInt(enab[i],"kHVCard");
			int hvCh = map->GetInt(enab[i],"kHVChan");
			int targetHV = map->GetInt(enab[i],"kMaxVoltage");
			int actualHV = set->GetInt("targets",hvCr,hvCa,hvCh,"OREHS8260pModel");
			double ratio = (double)targetHV/actualHV;
			if (ratio > 1.01 || ratio < 0.99)
				printf("HV Difference!  Run %i  Chan %i  Det %s  Target %i  Actual %i  Ratio %.2f\n",run, enab[i], detector.c_str(), targetHV, actualHV, ratio);


			// baseline values (skip pulser monitors)
			char treename[200];
			sprintf(treename,"%s_Baseline",detector.c_str());
			TTree *base = (TTree*)scFile->Get(treename);
			if (!scFile->GetListOfKeys()->Contains(treename)) {
				cout << "Tree " << treename << " not found.  Continuing ...\n"; continue;
			}
			TH1D *h2 = new TH1D("h2","",850,-11,6);
			sprintf(cutstr,"unixtime >= %li && unixtime <= %li",start,stop);
			base->Project("h2", "value", cutstr);

			if (h2->GetEntries() > 0) {
				double mean = h2->GetMean();
				if (fabs(mean) < 50) {
					baselineMeans[chanIndex].push_back(mean);
					baselineRMSs[chanIndex].push_back(mean);
				}
			}
			else {
				baselineMeans[chanIndex].push_back(0);
				baselineRMSs[chanIndex].push_back(0);
			}
			delete base;
			delete h2;


			// leakage current values (skip pulser monitors)
			sprintf(treename,"%s_Leakage",detector.c_str());
			TTree *leak = (TTree*)scFile->Get(treename);
			if (!scFile->GetListOfKeys()->Contains(treename)) {
				cout << "Tree " << treename << " not found.  Continuing ...\n"; continue;
			}
			TH1D *h3 = new TH1D("h3","",100,-10,10); 	// not sure what right limits are ...
			leak->Project("h3","value",cutstr);
			if (h3->GetEntries() > 0) {
				leakageMeans[chanIndex].push_back(h3->GetMean());
				leakageRMSs[chanIndex].push_back(h3->GetRMS());
			}
			else {
				leakageMeans[chanIndex].push_back(0);
				leakageRMSs[chanIndex].push_back(0);
			}
			delete leak;
			delete h3;
		}


		delete ds;
		bench.Show("runScanTime");
		bench.Reset();

	} // end loop over run list

	cout << "Closing slow controls file ... ";
	scFile->Close();
	cout << "done.\n\n";


	////////////////////////////////////////////////////////////////////
	// ====================== Write some plots ====================== //
	////////////////////////////////////////////////////////////////////

	char outname[200];
	sprintf(outname,"./output/%s.root",input.c_str());
	TFile *reportOutput = new TFile(outname,"RECREATE");
	map->Write();	// save the channel map for names
	cout << "Using output file: " << outname << endl;

	// TCanvas *can = new TCanvas("can","Bob Ross's Canvas",800,600);
	// gStyle->SetOptStat(0);
	// gPad->SetLeftMargin(.12);
	// gPad->SetRightMargin(.12);
	gErrorIgnoreLevel = 1001;	// 1001: ignore info messages
	char plotname[200];
	for (int i = 0; i < 62; i++)
	{
		string strName = map->GetString(chans[i],"kStringName");
		string detPos = to_string(map->GetInt(chans[i],"kDetectorPosition"));
		string detector = strName+"D"+detPos;

		if (hTrapENF[i]->GetEntries() > 0)
		{
			printf("%i  ch %i  entries %.0f\n",i, chans[i], hTrapENF[i]->GetEntries());
			char det[200];
			strcpy(det,detector.c_str());
			int chan = chans[i];

			// 1d energy spectra
			sprintf(plotname,"%s (%i) TrapENFCal",det,chan);
			hTrapENF[i]->SetTitle(plotname);
			hTrapENF[i]->GetXaxis()->SetTitle("trapENFCal");
			hTrapENF[i]->GetYaxis()->SetTitle("Counts");
			hTrapENF[i]->GetYaxis()->SetTitleOffset(1.5);
			hTrapENF[i]->Draw();
			sprintf(outname,"%i_TrapENF",chan);
			hTrapENF[i]->SetName(outname);
			hTrapENF[i]->Write(outname,TObject::kOverwrite);

			// rate
			hRate[i]->SetMarkerColor(kBlue);
			hRate[i]->SetMarkerStyle(kFullDotLarge);
			hRate[i]->Draw("AP");
			sprintf(plotname,"%s (%i) Rate",det,chan);
			hRate[i]->SetTitle(plotname);
			hRate[i]->GetXaxis()->SetTitle("Run");
			hRate[i]->GetYaxis()->SetTitle("Avg. Rate (Hz)");
			hRate[i]->GetYaxis()->SetTitleOffset(1.5);
			sprintf(outname,"%i_Rate",chan);
			hRate[i]->SetName(outname);
			hRate[i]->Write(outname,TObject::kOverwrite);

			// energy vs run
			hTrapVRun[i]->Draw("COLZ");
			sprintf(plotname,"%s (%i) Energy v. Run",det,chan);
			hTrapVRun[i]->SetTitle(plotname);
			hTrapVRun[i]->GetXaxis()->SetNdivisions(9,5,0);
			hTrapVRun[i]->GetXaxis()->SetTitle("Run");
			hTrapVRun[i]->GetYaxis()->SetTitle("trapENFCal");
			hTrapVRun[i]->GetYaxis()->SetTitleOffset(1.5);
			sprintf(outname,"%i_EnergyVsRun",chan);
			hTrapVRun[i]->SetName(outname);
			hTrapVRun[i]->Write(outname,TObject::kOverwrite);

			// calibration constants (skip pulser monitors)
			if (chan==644 || chan==612 || chan==596 || chan==676) continue;
			hConst[i]->SetMarkerColor(kBlue);
			hConst[i]->SetMarkerStyle(kFullDotLarge);
			hConst[i]->Draw("AP");
			sprintf(plotname,"%s (%i) Calib Const",det,chan);
			hConst[i]->SetTitle(plotname);
			hConst[i]->GetXaxis()->SetTitle("Run");
			hConst[i]->GetYaxis()->SetTitle("Scale");
			hConst[i]->GetYaxis()->SetTitleOffset(1.5);
			sprintf(outname,"%i_CalConst",chan);
			hConst[i]->SetName(outname);
			hConst[i]->Write(outname,TObject::kOverwrite);


			// baseline & leakage plots
			vector<double> runListErr;
			for (int i = 0; i < (int)runList.size(); i++) runListErr.push_back(0);

			TGraphErrors *hBaseline = new TGraphErrors(runList.size(),&(runList[0]), &(baselineMeans[i][0]),&(runListErr[0]), &(baselineRMSs[i][0]));
			hBaseline->SetMarkerColor(kBlue);
			hBaseline->SetMarkerStyle(kFullDotLarge);
			hBaseline->SetTitle("Baseline");

			TGraphErrors *hLeakage = new TGraphErrors(runList.size(),&(runList[0]), &(leakageMeans[i][0]),&(runListErr[0]), &(leakageRMSs[i][0]));
			hLeakage->SetMarkerColor(kRed);
			hLeakage->SetMarkerStyle(kFullDotLarge);
			hLeakage->SetTitle("Leakage");

			TMultiGraph *mg = new TMultiGraph();
			mg->Add(hBaseline,"AP");
			mg->Add(hLeakage,"APY+");
			mg->Draw("a");
			sprintf(plotname, "%s (%i) Baseline v. Run",det,chan);
			mg->SetTitle(plotname);
			mg->GetXaxis()->SetTitle("Run");
			mg->GetYaxis()->SetTitle("Baseline (blue), Leakage (red)");
			sprintf(outname,"%i_Baseline",chan);
			mg->SetName(outname);
			mg->Write(outname,TObject::kOverwrite);

		}
	}
	reportOutput->Close();
}


///////////////////////////////////////////////////////////////////
// ==================== Find calib. const's ==================== //
///////////////////////////////////////////////////////////////////

// calibration constants format:
// [0] calib range lo	[1] calib range hi  (calibration runs used)
// [2] run range lo		[3] run range hi	(runs calibration applies to)
// [4] scale constant 	[5] scale uncertainty
// [6] offset constant	[7] offset uncertainty
// [8 - 11] covariance matrix values
vector<double> GetCalibrationConstants(MJAnalysisDoc &doc, int run, int chan)
{
	vector<double> result;

	// doc is passed by reference to avoid copying
	MJDocument runRecords = doc.GetRunRecords();
	size_t numRows = runRecords["rows"].Length();

	string channel = to_string(chan);
	// printf("\nRun %i  Channel %i ... found %lu records.\n",run, chan, numRows);

	// Figure out the name of the calibration parameter we need for this channel
	int rowMatch = -1;
	bool foundMatch = false;
	string calParamName = "";
	vector< vector<string> > chan_sources(numRows, vector<string>());
	for (size_t loop = 0; loop < numRows; loop++)
	{
		KTree prov = runRecords["rows"][loop]["doc"]["provenance"];

		// save the names of the calibration parameters
		string paramSource = prov["parameters_source"];
		string chanName = prov["channel_identifier"];
		chan_sources[loop].push_back(chanName);		//chan_sources[loop][0] : analysis channel
		chan_sources[loop].push_back(paramSource);	//chan_sources[loop][1] : parameter name
	}
	for (int i = 0; i < (int)chan_sources.size(); i++)
	{
		// find the "trapENF*" parameter for this channel in the vector "chan_sources"
		if (chan_sources[i][0] == channel && chan_sources[i][1].find("trapENF") != string::npos)
		{
			calParamName = chan_sources[i][1];
			foundMatch = true;
			rowMatch = i;
			// printf("Channel %i uses parameter '%s' \n", chan, calParamName.c_str());
		}
	}
	if (!foundMatch) {
		// cout << "Got a light?  I couldn't find a match!\n";
		return vector<double>();
	}

	// Load the EnergyCalibration and the provenance for the matched entry
	EnergyCalibration cal;
	KTree fExtraKeys;
	AddKey(fExtraKeys, kParametersSource, calParamName);
	size_t numRecs = doc.GetAnalysisParameter(run, chan, cal.GetPType(), fExtraKeys);

	KTree prov = runRecords["rows"][rowMatch]["doc"]["provenance"];
	string valid = prov["valid"];
	if (valid == "false") { cout << "Invalid database entry!\n";  return vector<double>(); }

	string sysID = prov["system_identifier"];
	string paramSource = prov["parameters_source"];	// the name of the desired calibration parameter "trapENF*"
	string paramType = prov["parameters_type"];
	string detName = prov["detector_identifier"];
	string chanName = prov["channel_identifier"];

	result.push_back(stod(prov["run_identifier"][0].As<string>())); // calibration runs
	result.push_back(stod(prov["run_identifier"][1].As<string>()));
	result.push_back(stod(prov["run_coverage"][0].As<string>()));	// runs the calibration applies to
	result.push_back(stod(prov["run_coverage"][1].As<string>()));

	if (numRecs == 0)
	{
		printf("No records found for channel %i, run %i.\n",run,chan);
		string statusMessage;
		if (doc.GetDBStatus(statusMessage)) cout << "DB status: " << statusMessage << endl;
		else cout << "DB status is blank.\n";
	}
	else if (numRecs == 1)
	{
		// assigns values to cal's member variables: scale, offset, covariance.
		cal.GetDBValue(doc);

		string type = cal.GetPType();
		double scale = cal.Scale.Value(), scaleUnc = cal.Scale.Uncertainty();
		result.push_back(scale); result.push_back(scaleUnc);

		double offset = cal.Offset.Value(), offsetUnc = cal.Offset.Uncertainty();
		result.push_back(offset); result.push_back(offsetUnc);

		double covar[4];
		for (int q = 0; q < 4; q++) { covar[q] = cal.Covariance.Value(q); result.push_back(covar[q]); }
	}
	else
	{
		// More than one record.  Requires a loop over the records and either
		// action on each of the results or better criteria.
		doc.PrintTree();
		cout << "Found multiple records! Clint needs to work harder." << endl;
	}

	return result;
}

///////////////////////////////////////////////////////////////////
// ================= Merge Report Output Files ================= //
// This is so one can split the run lists, process in parallel,  //
// then combine the output files back into a single file.        //
// Multilated from $ROOTSYS/tutorials/hadd.C -- Thanks, Rene!    //
///////////////////////////////////////////////////////////////////

// NOTE: right now, this takes the list of keys from the first file.
// If a channel is disabled / comes back, this routine may miss it.
// Probably better to compare the key names against the DS1_M1Channels array.

void MergeOutputFiles(int argc, char** argv, int chans[62])
{
	// Set output file and path
	char outputFile[200];
	sprintf(outputFile,"./output/%s.root",argv[0]);
	TDirectory *target = TFile::Open(outputFile, "RECREATE");
	cout << "\nWriting to output file : " << outputFile << endl;
	TString path( (char*)strstr( target->GetPath(), ":" ) );
    path.Remove( 0, 2 );

	// Add files to be merged (starting with argument 2)
	TList *sourceList = new TList();
	for (int i = 2; i < argc; i++) {
		char file[200];
		sprintf(file,"./output/%s.root",argv[i]);
		cout << "Added " << file << " to the processing list ... " << endl;
		sourceList->Add(TFile::Open(file));
	}

	// Open first source file and get its list of keys
	// Loop over the first file's items
	// Gain time, do not add the objects in the list in memory
	TFile *firstSource = (TFile*)sourceList->First();
    Bool_t status = TH1::AddDirectoryStatus();
    TH1::AddDirectory(kFALSE);
	TIter nextkey(firstSource->GetListOfKeys());
	TKey *key = 0;
	while ((key = (TKey*)nextkey()))
	{
		TObject *obj = key->ReadObj();

		// TH1D case
		if (obj->IsA()->InheritsFrom(TH1D::Class()))
		{
			TH1D *h1 = (TH1D*)obj;
			// printf("File : %s  Object : %s  Entries: %.0f\n", firstSource->GetPath(), h1->GetName(), h1->GetEntries());
            TFile *nextSource = (TFile*)sourceList->After(firstSource);
            while (nextSource)
			{
				// make sure we are at the correct directory level by cd'ing to path
				nextSource->cd( path );

				// Find the object (same name) in nextSource and add it to h1.
				TKey *key2 = (TKey*)gDirectory->GetListOfKeys()->FindObject(h1->GetName());
				if (key2)
				{
					TH1D *h2 = (TH1D*)key2->ReadObj();
					// printf("File : %s  Object : %s  Entries: %.0f\n", nextSource->GetPath(),h2->GetName(),h2->GetEntries());
					h1->Add(h2);
					delete h2;
				}
				nextSource = (TFile*)sourceList->After(nextSource);
            }
			// Now write the merged histogram (which is "in" obj) to the target file.
			// Note that this will just store obj in the current directory level,
			// which is not persistent until the complete directory itself is stored
			// by "target->Write()".
			target->cd();
			obj->Write( key->GetName() );
			target->Write();
		}

		// TH2D case
		if (obj->IsA()->InheritsFrom(TH2D::Class()))
		{
			TH2D *h0 = (TH2D*)obj;

			// store th2d data
			vector<tuple<double,double,double>> triplets;

			// store first histo
			int h0Bins = h0->GetNbinsX();
			TH1 *hbins0[h0Bins];
			for (int i = 0; i <= h0Bins; i++) {
				hbins0[i] = h0->ProjectionY(Form("bin%d",i),i,i); // name,firstxbin,lastxbin
				int size = hbins0[i]->GetNbinsX();
				int run = h0->GetXaxis()->GetBinCenter(i);
				for (int j = 0; j < size; j++){
					int w = hbins0[i]->GetBinContent(j);
					if (w > 0){
						double ene = hbins0[i]->GetBinCenter(j);
						if (ene < 0) ene = 1;
						tuple<double,double,double> temp = make_tuple((double)run,ene,(double)w);
						triplets.push_back(temp);
					}
				}
			}

			TFile *nextSource = (TFile*)sourceList->After(firstSource);
            while (nextSource)
			{
				nextSource->cd( path );
				TKey *key2 = (TKey*)gDirectory->GetListOfKeys()->FindObject(h0->GetName());
				if (key2)
				{
					TH2D *h1 = (TH2D*)key2->ReadObj();
					int h1Bins = h0->GetNbinsX();
					TH1 *hbins1[h0Bins];
					for (int i = 0; i <= h1Bins; i++) {
						hbins1[i] = h1->ProjectionY(Form("bin%d",i),i,i); // name,firstxbin,lastxbin
						int size = hbins1[i]->GetNbinsX();
						int run = h1->GetXaxis()->GetBinCenter(i);
						for (int j = 0; j < size; j++){
							int w = hbins1[i]->GetBinContent(j);
							if (w > 0){
								double ene = hbins1[i]->GetBinCenter(j);
								if (ene < 0) ene = 1;
								tuple<double,double,double> temp = make_tuple((double)run,ene,(double)w);
								triplets.push_back(temp);
							}
						}
					}
				}
				nextSource = (TFile*)sourceList->After(nextSource);
			}

			// make the output histogram
			tuple<double,double,double> firstEntry = triplets.front();
			tuple<double,double,double> lastEntry = triplets.back();
			int xmin = get<0>(firstEntry);
			int xmax = 1 + get<0>(lastEntry);
			int xBins = 1 + xmax - xmin;
			TH2D *output = new TH2D(obj->GetName(),obj->GetTitle(),xBins,xmin,xmax,300,0,3000);
			for ( vector < tuple<double,double,double> >::const_iterator it = triplets.begin(); it != triplets.end();  it++)
			{
				tuple<double,double,double> temp = *it;
				int run = get<0>(temp);
				int ene = get<1>(temp);
				int cts = get<2>(temp);
				output->Fill(run,ene,cts);
			}
			target->cd();
			output->Write( key->GetName() );
			target->Write();
		}

		// TGraph case
		if (obj->IsA()->InheritsFrom(TGraph::Class()))
		{
			TGraph *g1 = (TGraph*)obj;
			// printf("File 1 : %s  Object : %s  Entries: %i\n", firstSource->GetPath(), obj->GetName(), g1->GetN());
			int n = g1->GetN();
			TFile *nextSource = (TFile*)sourceList->After(firstSource);
			while (nextSource)
			{
	            nextSource->cd( path );

				// Add the points from nextSource to the g1 object
				TKey *key2 = (TKey*)gDirectory->GetListOfKeys()->FindObject(g1->GetName());
				if (key2)
				{
					TGraph *g2 = (TGraph*)key2->ReadObj();
					// printf("File 2 : %s  Object : %s  Entries: %i\n", nextSource->GetPath(), g2->GetName(), g2->GetN());
					double x=-1, y=-1;
					for (int j = 0; j < g2->GetN(); j++)
					{
						g2->GetPoint(j,x,y);
						// printf("%s  %i  x: %.0f  y: %.2f\n",obj2->GetName(),j+n,x,y);
						g1->SetPoint(j+n,x,y);
					}
					delete g2;
					n += g2->GetN();
				}
				nextSource = (TFile*)sourceList->After(nextSource);
			}
			target->cd();
			obj->Write( key->GetName() );
			target->Write();

		}

		// TMultiGraph (of TGraphErrors) case
		if (obj->IsA()->InheritsFrom(TMultiGraph::Class()))
		{
			TMultiGraph *g1 = (TMultiGraph*)obj;
			// printf("File 1 : %s  Object : %s  Graphs: %i\n", firstSource->GetPath(), obj->GetName(), g1->GetListOfGraphs()->GetSize());
			TList *graphs = g1->GetListOfGraphs();
			TGraphErrors *base = (TGraphErrors*)graphs->First();
			TGraphErrors *leak = (TGraphErrors*)graphs->After(base);
			int n = base->GetN();

			TFile *nextSource = (TFile*)sourceList->After(firstSource);
			while (nextSource)
			{
	            nextSource->cd( path );
				TKey *key2 = (TKey*)gDirectory->GetListOfKeys()->FindObject(g1->GetName());
				if (key2)
				{
					TMultiGraph *g2 = (TMultiGraph*)key2->ReadObj();
					TList *tmpGraphs = g2->GetListOfGraphs();
					TGraphErrors *tmpBase = (TGraphErrors*)tmpGraphs->First();
					TGraphErrors *tmpLeak = (TGraphErrors*)tmpGraphs->After(tmpBase);

					double x=-1,y=-1,xe=-1,ye=-1;
					for (int j = 0; j < tmpBase->GetN(); j++)
					{
						tmpBase->GetPoint(j,x,y);
						xe = tmpBase->GetErrorX(j);
						ye = tmpBase->GetErrorY(j);
						base->SetPoint(j+n,x,y);
						base->SetPointError(j+n,xe,ye);
						// printf("%s  %i  x: %.0f (%.0f)  y: %.2f (%.2f)\n",tmpBase->GetTitle(),j+n,x,xe,y,ye);
						tmpLeak->GetPoint(j,x,y);
						xe = tmpLeak->GetErrorX(j);
						ye = tmpLeak->GetErrorY(j);
						leak->SetPoint(j+n,x,y);
						leak->SetPointError(j+n,xe,ye);
					}
					delete g2;
					n += tmpBase->GetN();
				}
				nextSource = (TFile*)sourceList->After(nextSource);
			}
			// don't output obj this time, it doesn't seem to work.
			// make a new TMultiGraph and explicity add "base" and "leak"
			TMultiGraph *output = new TMultiGraph(key->GetName(),key->GetTitle());
			output->Add(base);
			output->Add(leak);
			target->cd();
			// obj->Write( key->GetName() );
			output->Write();
			target->Write();
			delete output;
		}
	}

	// save modifications to target file
	target->SaveSelf(kTRUE);
	TH1::AddDirectory(status);
}

///////////////////////////////////////////////////////////////////
// ==================== Create Summary Plots =================== //
// This takes a merged datafile (from mergeOutput) and generates //
// a bunch of .pdf plots.                                        //
///////////////////////////////////////////////////////////////////

void makePlots(int argc, char** argv, int chans[62])
{
	string mergeFile = "./output/";
	mergeFile += argv[0];
	mergeFile += ".root";

	string mapFile = argv[2];
	mapFile += ".root";
	TFile *tmp = new TFile(mapFile.c_str());
	MJTChannelMap *map = dynamic_cast<MJTChannelMap*>(tmp->Get("ChannelMap"));
	tmp->Close();

	cout << "mergeFile: " << mergeFile << "  mapFile: " << mapFile << endl;

	TCanvas *c = new TCanvas("c","Bob Ross's Canvas",800,520);
	TCanvas *c2 = new TCanvas("c2","Bob Ross's Canvas",1600,450);	//TH2D
	TFile *f = new TFile(mergeFile.c_str());
	TIter nextkey(f->GetListOfKeys());
	TKey *key = 0;
	while ((key = (TKey*)nextkey()))
	{
		TObject *obj = key->ReadObj();
		char plotName[200];
		string keyName(obj->GetName());
		string chanName = keyName.substr(0, keyName.find("_"));
		int chan = stoi(chanName);
		bool foundDet=false;
		string detSerial, strName, detPos, detector;
		for (int i = 0; i < 62; i++) if (chan == chans[i]) foundDet=true;
		if (foundDet) {
			if (chan==644||chan==612||chan==596||chan==676){
				detSerial = "";
				detector = "Pulser Monitor";
			}
			else {
				detSerial = map->GetString(chan,"kDetectorName");
				strName = map->GetString(chan,"kStringName");
				detPos = to_string(map->GetInt(chan,"kDetectorPosition"));
				detector = strName+"D"+detPos;
			}
		}
		else continue;	// skip channels not in master array
		char title[200];
		sprintf(title,"%s %s (%i)",detSerial.c_str(),detector.c_str(),chan);

		// 1. TH1D energy spectrum
		// 2. TGraph rate
		// 3. TH2D energy vs run
		// 4. TGraph calibration constants
		// 5. TMultiGraph baseline & leakage

		if (obj->IsA()->InheritsFrom(TH1D::Class()))
		{
			TH1D *h1 = (TH1D*)obj;
			c->Clear();
			c->SetLogy();
			h1->Draw();
			char thisTitle[200];
			sprintf(thisTitle,"TrapENFCal, %s",title);
			h1->SetTitle(thisTitle);
			h1->GetXaxis()->SetTitleOffset(0.9);
			sprintf(plotName,"./plots/%s.pdf",obj->GetName());
			c->Print(plotName);
		}

		if (obj->IsA()->InheritsFrom(TH2D::Class()))
		{
			TH2D *h1 = (TH2D*)obj;
			c2->Clear();
			c2->SetLogy(1);
			c2->SetLogz(1);
			h1->Draw("COLZ");
			char thisTitle[200];
			sprintf(thisTitle,"Energy V. Run, %s",title);
			h1->SetTitle(thisTitle);
			h1->GetXaxis()->SetTitleOffset(0.7);
			h1->GetYaxis()->SetTitleOffset(0.4);
			h1->GetXaxis()->SetTitle("Run");
			h1->GetYaxis()->SetTitle("TrapENFCal");
			sprintf(plotName,"./plots/%s.pdf",obj->GetName());
			c2->Print(plotName);
		}

		if (obj->IsA()->InheritsFrom(TGraph::Class()))
		{
			TGraph *g1 = (TGraph*)obj;

			// Plot the rate plot on a log scale
			char thisTitle[200];
			string type(obj->GetName());
			c->SetLogy(0);
			size_t found = type.find("Rate");
			if (found!=string::npos){
				c->SetLogy();
				g1->SetMarkerColor(kBlue);
				g1->SetMarkerStyle(kFullDotMedium);
				g1->GetYaxis()->SetTitle("Rate (Hz)");
				sprintf(thisTitle,"Rate, %s",title);
				g1->SetTitle(thisTitle);
			}
			// Plot the calib const on a lin scale
			else {
				g1->SetMarkerColor(kRed);
				g1->SetMarkerStyle(kFullDotMedium);
				// g1->GetYaxis()->SetTitle("");
				sprintf(thisTitle,"Calib Const, %s",title);
				g1->SetTitle(thisTitle);
			}
			c->Clear();
			g1->Draw("AP");
			g1->GetXaxis()->SetTitle("Run");
			g1->GetXaxis()->SetTitleOffset(0.9);
			sprintf(plotName,"./plots/%s.pdf",obj->GetName());
			c->Print(plotName);
		}

		if (obj->IsA()->InheritsFrom(TMultiGraph::Class()))
		{
			TMultiGraph *mg = (TMultiGraph*)obj;
			TList *graphs = mg->GetListOfGraphs();
			TGraphErrors *base = (TGraphErrors*)graphs->First();
			TGraphErrors *leak = (TGraphErrors*)graphs->After(base);
			c->Clear();

			// don't draw leakage, it's always zero
			base->Draw("AP");
			char thisTitle[200];
			sprintf(thisTitle,"Baseline, %s",title);
			base->SetTitle(thisTitle);
			base->GetXaxis()->SetTitle("Run");
			base->GetYaxis()->SetTitle("Voltage");
			base->GetXaxis()->SetTitleOffset(0.9);
			sprintf(plotName,"./plots/%s.pdf",obj->GetName());
			c->Print(plotName);
		}
	}
	delete c;

	// before re-running the macro?
	delete map;
}


///////////////////////////////////////////////////////////////////
// ==================== Make LaTeX plot code =================== //
// Pipe the output to a text file:                               //
// $ ./reportQuality DS1RangeInfo -T > figureList.txt            //
///////////////////////////////////////////////////////////////////

void makeTex(string input, int chans[62])
{
	input += ".root";
	TFile *tmp = new TFile(input.c_str());
	MJTChannelMap *map = dynamic_cast<MJTChannelMap*>(tmp->Get("ChannelMap"));
	tmp->Close();

	string names[31] = {"P1D1","P1D2","P1D3","P1D4","P2D1","P2D2","P2D3","P2D4","P2D4","P3D1","P3D2","P3D3","P3D4","P3D4","P4D1","P4D2","P4D3","P4D4","P4D5","P5D1","P5D2","P5D3","P5D4","P6D1","P6D2","P6D3","P6D4","P7D1","P7D2","P7D3","P7D4"};

	for (int i = 0; i < 31; i++){

		for (int j = 0; j < 62; j++){

			int chan = chans[j];

			if (chan % 2 == 0 && chan!=630 && chan!=642 && chan!=584 && chan!=680 && chan!=696 && chan!=688){
				string name,cryo,det;

				if (chan==644||chan==612||chan==596||chan==676) continue;

				det = map->GetDetectorName(chan);
				name = map->GetDetectorPos(chan);
				cryo = "C1";
				string::size_type q = name.find(cryo);
				if (q != string::npos) name.erase(q,cryo.length());

				if (names[i] == name){
					cout << "\\newpage"<< endl;
					cout << "\\section{" << name << "  (" << det << ")}" <<endl;
					cout << "\\begin{figure}[!htb]" << endl;
					cout << "\t\\hspace*{-0.8cm}\\includegraphics[width=1.05\\textwidth]{./plots/"<<chan<<"_EnergyVsRun}" << endl;
					cout << "\t\\includegraphics[width=0.5\\textwidth]{./plots/"<<chan<<"_TrapENF}" << endl;
					cout << "\t\\includegraphics[width=0.5\\textwidth]{./plots/"<<chan+1<<"_TrapENF}" << endl;
					cout << "\t\\includegraphics[width=0.5\\textwidth]{./plots/"<<chan<<"_Rate}" << endl;
					cout << "\t\\includegraphics[width=0.5\\textwidth]{./plots/"<<chan+1<<"_Rate}" << endl;
					cout << "\t\\includegraphics[width=0.5\\textwidth]{./plots/"<<chan<<"_Baseline}" << endl;
					cout << "\t\\includegraphics[width=0.5\\textwidth]{./plots/"<<chan<<"_CalConst}" << endl;
					cout << "\\end{figure}\n\n";
				}

			}
		}

	}

	// do pulser monitors last
	cout << "\\newpage"<< endl;
	cout << "\\section{Pulser Monitors}" << endl;
	int monitors[4] = {644,612,596,676};
	for (int i = 0; i < 4; i++){
		int chan = monitors[i];
		string name = "Monitor "+to_string(chan);
		cout << "\\begin{figure}[!htb]" << endl;
		cout << "\t\\includegraphics[width=0.5\\textwidth]{./plots/"<<chan<<"_TrapENF}" << endl;
		cout << "\t\\includegraphics[width=0.5\\textwidth]{./plots/"<<chan<<"_Rate}" << endl;
		cout << "\\end{figure}\n\n";
	}
}

